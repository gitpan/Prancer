.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Prancer::Application 3"
.TH Prancer::Application 3 "2014-03-31" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Prancer::Application
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
This package is where your application should start.
.PP
.Vb 1
\&    package MyApp;
\&
\&    use Prancer::Application qw(:all);
\&    use parent qw(Prancer::Application);
\&
\&    sub new {
\&        my $class = shift;
\&        my $self = $class\->SUPER::new(shift);
\&
\&        # when prancer is instantiated, the programmer has the option to pass
\&        # extra arguments after the handler class name. those arguments will end
\&        # up in here!
\&        #
\&        # of course, you don\*(Aqt have to write a \->new method if you don\*(Aqt want to as
\&        # one is created automatically in Prancer::Application. but that means that
\&        # if you DO create one you must call to \->SUPER::new first and you MUST
\&        # pass the first argument to \->new (after $class) to \->SUPER::new in order
\&        # for Prancer to work correctly.
\&
\&        return $self;
\&    }
\&
\&    sub handle {
\&        my ($self, $env) = @_;
\&
\&        mount(\*(AqGET\*(Aq, \*(Aq/\*(Aq, sub {
\&            context\->header(set => \*(AqContent\-Type\*(Aq, value => \*(Aqtext/plain\*(Aq);
\&            context\->body("hello world");
\&            context\->finalize(200);
\&        });
\&
\&        return dispatch;
\&    }
.Ve
.PP
A new instance of this package is created on every request so that request
specific fields may be filled in and available. It also means that your code
should be as lightweight as possible.
.PP
Your class should implement \f(CW\*(C`handle\*(C'\fR. Two arguments are passed to this method:
the instance of your class created for this request and \f(CW$env\fR for the
request. You probably don't need to use \f(CW$env\fR because the methods detailed
below should give you everything you need, especially \f(CW\*(C`context\*(C'\fR.
.SH "EXPORTABLE"
.IX Header "EXPORTABLE"
The following methods are exportable: \f(CW\*(C`context\*(C'\fR, \f(CW\*(C`mount\*(C'\fR, \f(CW\*(C`dispatch\*(C'\fR,
\&\f(CW\*(C`config\*(C'\fR, \f(CW\*(C`logger\*(C'\fR, \f(CW\*(C`database\*(C'\fR, \f(CW\*(C`template\*(C'\fR. They can all be exported at
once with \f(CW\*(C`:all\*(C'\fR.
.SH "METHODS"
.IX Header "METHODS"
By default this package exports nothing. But that makes it difficult to use.
You should probably export \f(CW\*(C`:all\*(C'\fR. That will give you quick access to these
methods.
.IP "config" 4
.IX Item "config"
Passes through to \f(CW\*(C`Prancer::config\*(C'\fR. This is made available for your
application.
.IP "logger" 4
.IX Item "logger"
Passes through to \f(CW\*(C`Prancer::logger\*(C'\fR. This is made available for your
application.
.IP "database" 4
.IX Item "database"
Passes through to \f(CW\*(C`Prancer::database\*(C'\fR. This is made available for your
application.
.IP "template" 4
.IX Item "template"
Passes through to \f(CW\*(C`Prancer::template\*(C'\fR. This is made available for your
application.
.IP "context" 4
.IX Item "context"
This gives access to the request context. See Prancer::Context for more
information about what that makes available. But here is a short example:
.Sp
.Vb 3
\&    context\->header(set => \*(AqContent\-Type\*(Aq, value => \*(Aqtext/plain\*(Aq);
\&    context\->body("hello world");
\&    context\->finalize(200);
.Ve
.IP "mount \s-1METHOD, PATH, SUB\s0" 4
.IX Item "mount METHOD, PATH, SUB"
This adds a routed path. Prancer uses Router::Boom::Method to handle
routing. If it is not installed then calls to this method will croak. The first
argument will always be the method or methods that should match. For example:
.Sp
.Vb 2
\&    mount(\*(AqGET\*(Aq, ..., ...);
\&    mount([\*(AqGET\*(Aq,\*(AqPOST\*(Aq], ..., ...);
.Ve
.Sp
The second argument should be the path that will match. For example:
.Sp
.Vb 5
\&    mount(..., \*(Aq/\*(Aq, ...);
\&    mount(..., \*(Aq/:user\*(Aq, ...);
\&    mount(..., \*(Aq/blog/{year}\*(Aq, ...);
\&    mount(..., \*(Aq/blog/{year}/{month:\ed+}\*(Aq, ...);
\&    mount(..., \*(Aq/download/*\*(Aq, ...);
.Ve
.Sp
The last argument should be a sub that will run on a successful match. For
example:
.Sp
.Vb 2
\&    mount(..., ..., sub {
\&        my $captured = shift;
\&
\&        context\->header(set => \*(AqContent\-Type\*(Aq, value => \*(Aqtext/plain\*(Aq);
\&        context\->body("hello world");
\&        context\->finalize(200);
\&    });
.Ve
.Sp
Of course the sub doesn't have to be anonymous and could point to anything. The
only argument that gets passed to a sub is a hashref containing what, if
anything, was captured in the route. For example:
.Sp
.Vb 4
\&    mount(..., \*(Aq/\*(Aq, sub {
\&        my $captured = shift;
\&        # captured = {}
\&    });
\&
\&    # :user matches qr{([^/]+)}
\&    mount(..., \*(Aq/:user\*(Aq, sub {
\&        my $captured = shift;
\&        print $captured\->{\*(Aquser\*(Aq};
\&    });
\&
\&    # {year} matches qr{([^/]+)}
\&    mount(..., \*(Aq/blog/{year}/{month:\ed+}\*(Aq, sub {
\&        my $captured = shift;
\&        print $captured\->{\*(Aqyear\*(Aq};
\&        print $captured\->{\*(Aqmonth\*(Aq};
\&    });
\&
\&    # * matches qr{(.+)}
\&    mount(..., \*(Aq/download/*\*(Aq, sub {
\&        my $captured = shift;
\&        print $captured\->{\*(Aq*\*(Aq};
\&    });
.Ve
.Sp
Further documentation on how to use routes can be found by reading the docs
for Router::Boom and Router::Boom::Method.
.IP "dispatch" 4
.IX Item "dispatch"
This should be called at the end of your implementation to \f(CW\*(C`handle\*(C'\fR. It will
run the configured routes and return a valid \s-1PSGI\s0 response to the application
server. If you do not have Router::Boom installed then calling this method
will croak. If you are not using Router::Boom then you should not use this
method but should instead have your implementation of \f(CW\*(C`handle\*(C'\fR return a valid
\&\s-1PSGI\s0 response.
