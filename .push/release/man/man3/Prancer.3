.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Prancer 3"
.TH Prancer 3 "2014-03-31" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Prancer \- Another PSGI Framework
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
Prancer is yet another \s-1PSGI\s0 framework. This one is designed to be a bit smaller
and more out of the way than others but it could probably be described best as
project derived from \s-1NIH\s0 syndrome <https://en.wikipedia.org/wiki/Not_Invented_Here>.
.PP
Here's how it might be used:
.PP
.Vb 1
\&    ==> myapp.psgi
\&
\&    use Prancer;
\&    my $app = Prancer\->new("/path/to/confdir", "MyApp");
\&    $app\->run();
\&
\&    ==> MyApp.pm
\&
\&    package MyApp;
\&
\&    use Prancer::Application qw(:all);
\&    use parent qw(Prancer::Application);
\&
\&    sub handle {
\&        my $self = shift;
\&
\&        mount(\*(AqGET\*(Aq, \*(Aq/\*(Aq, sub {
\&            context\->header(set => \*(AqContent\-Type\*(Aq, value => \*(Aqtext/plain\*(Aq);
\&            context\->body("hello world");
\&            context\->finalize(200);
\&        });
\&
\&        return dispatch;
\&    }
.Ve
.PP
Full documentation can be found in Prancer::Manual.
.SH "INSTALLATION"
.IX Header "INSTALLATION"
To install this module, run the following commands:
.PP
.Vb 4
\&    perl Makefile.PL
\&    make
\&    make test
\&    make install
.Ve
.PP
If this ever makes it to \s-1CPAN\s0 you can install it with this simple command:
.PP
.Vb 1
\&    perl \-MCPAN \-e \*(Aqinstall Prancer\*(Aq
.Ve
.PP
These optional libraries will enhance the functionality of Prancer:
.IP "Template" 4
.IX Item "Template"
Without this the Prancer template interface will not work.
.IP "\s-1DBI\s0" 4
.IX Item "DBI"
Without this the Prancer database interface will not work. You also will need
a database driver like DBD::Pg.
.IP "Plack::Middleware::Session" 4
.IX Item "Plack::Middleware::Session"
Without this the Prancer session support will not work. If you want to use the
\&\s-1YAML\s0 session storage you will also need to have \s-1YAML\s0 (preferably
\&\s-1YAML::XS\s0) installed. If you want support to write sessions do the database
you will also need \s-1DBI\s0 installed along with a database driver like
DBD::Pg.
.SH "EXPORTABLE"
.IX Header "EXPORTABLE"
The following methods are exportable: \f(CW\*(C`config\*(C'\fR, \f(CW\*(C`logger\*(C'\fR, \f(CW\*(C`database\*(C'\fR,
\&\f(CW\*(C`template\*(C'\fR. They can all be exported at once using \f(CW\*(C`:all\*(C'\fR.
.SH "METHODS"
.IX Header "METHODS"
With the exception of \f(CW\*(C`\->new\*(C'\fR and \f(CW\*(C`\->run\*(C'\fR, all methods should be
called in a static context. Additionally, with the same exception, all methods
are exportable individually or with \f(CW\*(C`qw(:all)\*(C'\fR.
.IP "\->new \s-1CONFIG PACKAGE ARGS\s0" 4
.IX Item "->new CONFIG PACKAGE ARGS"
This will create your application. It takes two arguments:
.RS 4
.IP "\s-1CONFIG\s0" 4
.IX Item "CONFIG"
This a path to a directory containing configuration files. How configuration
files are loaded is detailed below.
.IP "\s-1PACKAGE\s0" 4
.IX Item "PACKAGE"
This is the name of a package that implements your application. The package
named should extend Prancer::Application though this is not enforced.
.IP "\s-1ARGS\s0" 4
.IX Item "ARGS"
After the name of the package, any number of arguments may be added. Any extra
arguments are passed directly to the \f(CW\*(C`new\*(C'\fR method on the named package when it
is created for a request.
.RE
.RS 4
.RE
.IP "\->run" 4
.IX Item "->run"
This starts your application. It takes no arguments.
.IP "logger" 4
.IX Item "logger"
This gives access to the logger. For example:
.Sp
.Vb 3
\&    logger\->info("Hello");
\&    logger\->fatal("uh oh");
\&    logger\->debug("here we are");
.Ve
.IP "config" 4
.IX Item "config"
This gives access to the configuration. For example:
.Sp
.Vb 4
\&    config\->has(\*(Aqfoo\*(Aq);
\&    config\->get(\*(Aqfoo\*(Aq);
\&    config\->set(\*(Aqfoo\*(Aq, value => \*(Aqbar\*(Aq);
\&    config\->remove(\*(Aqfoo\*(Aq);
.Ve
.Sp
Any changes to the configuration do not persist back to the actual
configuration file. Additionally they do not persist between threads or
processes.
.Sp
Whenever this method is used to get a configuration option and that option
is reference, the reference will be cloned by Storable to prevent changes to
one copy from affecting other uses. But this could have performance
implications if you are routinely getting large data structures out if your
configuration files.
.IP "template" 4
.IX Item "template"
This gives access to the configured template engine. For example:
.Sp
.Vb 4
\&    print template("foo.tt", {
\&        \*(Aqtitle\*(Aq => \*(Aqfoobar\*(Aq,
\&        \*(Aqvar1\*(Aq => \*(Aqval2\*(Aq,
\&    });
.Ve
.Sp
If no template engines are configured then this method will always return
\&\f(CW\*(C`undef\*(C'\fR.
.IP "database" 4
.IX Item "database"
This gives access to the configured databases. For example:
.Sp
.Vb 2
\&    # handle to the database configured as \*(Aqdefault\*(Aq
\&    my $dbh = database;
\&
\&    # handle to the database configured as \*(Aqfoo\*(Aq
\&    my $dbh = database(\*(Aqfoo\*(Aq);
\&
\&    # prepare a statement on connection \*(Aqdefault\*(Aq
\&    my $sth = database\->prepare("SELECT * FROM foo");
.Ve
.Sp
In all cases, \f(CW$dbh\fR will be a reference to a \s-1DBI\s0 handle and anything that
can be done with \s-1DBI\s0 can be done here.
.Sp
If no databases are configured then this method will always return \f(CW\*(C`undef\*(C'\fR.
.IP "session" 4
.IX Item "session"
Configures the session handler. For example:
.Sp
.Vb 9
\&    session:
\&        state:
\&            driver: Prancer::Session::State::Cookie
\&            options:
\&                key: PSESSION
\&        store:
\&            driver: Prancer::Session::Store::YAML
\&            options:
\&                path: /tmp/prancer/sessions
.Ve
.Sp
See Prancer::Session::State::Cookie, Prancer::Session::Store::Memory,
Prancer::Session::Store::YAML and Prancer::Session::Store::Database for
more options.
.SH "CONFIGURATION"
.IX Header "CONFIGURATION"
One doesn't need to create any configuration to use Prancer but then Prancer
wouldn't be very useful. Prancer uses Config::Any to process configuration
files so anything supported by that will be supported by this. It will load
configuration files from given path set when your application initialized.
First it will look for a file named \f(CW\*(C`config.ext\*(C'\fR where \f(CW\*(C`ext\*(C'\fR is something
like \f(CW\*(C`yml\*(C'\fR or \f(CW\*(C`ini\*(C'\fR. Then it will look for a file named after the current
environment like \f(CW\*(C`develoment.ext\*(C'\fR or \f(CW\*(C`production.ext\*(C'\fR. The environment is
derived by looking first for an environment variable called \f(CW\*(C`ENVIRONMENT\*(C'\fR,
then for an environment variable called \f(CW\*(C`PLACK_ENV\*(C'\fR. If neither of those exist
then the default is \f(CW\*(C`development\*(C'\fR. Configuration files will be merged such
that the environment configuration file will take precedence over the global
configuration file.
.PP
Arbitrary configuration directives can be put into your configuration files
and they can be accessed like this:
.PP
.Vb 1
\&    config(get => \*(Aqfoo\*(Aq);
.Ve
.PP
The configuration accessors will only give you configuration directives found
at the root of the configuration file. So if you use any data structures you
will have to decode them yourself. For example, if you create a \s-1YAML\s0 file like
this:
.PP
.Vb 3
\&    foo:
\&        bar1: asdf
\&        bar2: fdsa
.Ve
.PP
Then you will only be able to get the value to \f(CW\*(C`bar1\*(C'\fR like this:
.PP
.Vb 1
\&    my $foo = config(get => \*(Aqfoo\*(Aq)\->{\*(Aqbar1\*(Aq};
.Ve
.SS "Reserved Configuration Options"
.IX Subsection "Reserved Configuration Options"
To support the components of Prancer, these keys are used:
.IP "logger" 4
.IX Item "logger"
Configures the logging system. For example:
.Sp
.Vb 4
\&    logger:
\&        driver: Prancer::Logger::WhateverLogger
\&        options:
\&            level: debug
.Ve
.Sp
For the console logger, see Prancer::Logger::Console for more options.
.IP "template" 4
.IX Item "template"
Configures the templating system. For example:
.Sp
.Vb 7
\&    template:
\&        driver: Prancer::Template::WhateverEngine
\&        options:
\&            template_dir: /srv/www/site/templates
\&            encoding: utf8
\&            start_tag: "<%"
\&            end_tag: "%>"
.Ve
.Sp
For the Template Toolkit plugin, see Prancer::Template::TemplateToolkit for
more options.
.IP "database" 4
.IX Item "database"
Configures database connections. For example:
.Sp
.Vb 7
\&    database:
\&        default:
\&            driver: Prancer::Database::Driver::WhateverDriver
\&            options:
\&                username: test
\&                password: test
\&                database: test
.Ve
.Sp
See Prancer::Database for more options.
.IP "static" 4
.IX Item "static"
Configures a directory where static documents can be found and served using
Plack::Middleware::Static. For example:
.Sp
.Vb 2
\&    static:
\&        path: /srv/www/site/static
.Ve
.Sp
The only configuration option for static documents is \f(CW\*(C`path\*(C'\fR. If this path
is not defined your application will not start. If this path does not point
to a directory that is readable your application will not start.
.SH "CREDITS"
.IX Header "CREDITS"
Large portions of this library were taken from the following locations and
projects:
.IP "\(bu" 4
\&\s-1HTTP\s0 status code documentation taken from Wikipedia <http://www.wikipedia.org>.
.IP "\(bu" 4
Prancer::Config is derived directly from Dancer2::Core::Role::Config.
Thank you to the Dancer2 <https://github.com/PerlDancer/Dancer2> team.
.IP "\(bu" 4
Prancer::Request, Prancer::Request::Upload and Prancer::Response are
but thin wrappers to and reimplementations of Plack::Request,
Plack::Request::Upload and Prancer::Response. Thank you to Tatsuhiko
Miyagawa.
.IP "\(bu" 4
Prancer::Database is derived directly from Dancer::Plugin::Database.
Thank you to David Precious.
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 2013, 2014 Paul Lockaby. All rights reserved.
.PP
This library is free software; you can redistribute it and/or modify it under
the same terms as Perl itself.
