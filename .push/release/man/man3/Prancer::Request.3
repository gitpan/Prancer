.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Prancer::Request 3"
.TH Prancer::Request 3 "2014-03-25" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Prancer::Request
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&    sub handle {
\&        my $self = shift;
\&
\&        my $request = context\->request();
\&        my $path = $request\->path();
\&        my $cookie = $request\->cookie("foo");
\&        my $param = $request\->param("bar");
\&        my $cookie_names = $request\->cookie();
\&        my $user_agent = $request\->header("user\-agent");
\&
\&        ...
\&    }
.Ve
.SH "ATTRIBUTES"
.IX Header "ATTRIBUTES"
.IP "uri" 4
.IX Item "uri"
Returns an \s-1URI\s0 object for the current request. The \s-1URI\s0 is constructed using
various environment values such as \f(CW\*(C`SCRIPT_NAME\*(C'\fR, \f(CW\*(C`PATH_INFO\*(C'\fR,
\&\f(CW\*(C`QUERY_STRING\*(C'\fR, \f(CW\*(C`HTTP_HOST\*(C'\fR, \f(CW\*(C`SERVER_NAME\*(C'\fR and \f(CW\*(C`SERVER_PORT\*(C'\fR.
.IP "base" 4
.IX Item "base"
Returns a \s-1URI\s0 object for the base path of current request. This is like \f(CW\*(C`uri\*(C'\fR
but only contains up to \f(CW\*(C`SCRIPT_NAME\*(C'\fR where your application is hosted at.
.IP "method" 4
.IX Item "method"
Contains the request method (\f(CW\*(C`GET\*(C'\fR, \f(CW\*(C`POST\*(C'\fR, \f(CW\*(C`HEAD\*(C'\fR, etc).
.IP "protocol" 4
.IX Item "protocol"
Returns the protocol (\f(CW\*(C`HTTP/1.0\*(C'\fR or \f(CW\*(C`HTTP/1.1\*(C'\fR) used for the current request.
.IP "scheme" 4
.IX Item "scheme"
Returns the scheme (\f(CW\*(C`http\*(C'\fR or \f(CW\*(C`https\*(C'\fR) of the request.
.IP "secure" 4
.IX Item "secure"
Returns true or false, indicating whether the connection is secure (\f(CW\*(C`https\*(C'\fR).
.IP "path" 4
.IX Item "path"
Returns \fB\s-1PATH_INFO\s0\fR in the environment but returns / in case it is empty.
.IP "body" 4
.IX Item "body"
Returns a handle to the input stream.
.IP "address" 4
.IX Item "address"
Returns the \s-1IP\s0 address of the client (\f(CW\*(C`REMOTE_ADDR\*(C'\fR).
.IP "user" 4
.IX Item "user"
Returns \f(CW\*(C`REMOTE_USER\*(C'\fR if it's set.
.IP "header" 4
.IX Item "header"
When called with no arguments this will return a list of all header names.
When called in scalar context this will return the last value for the given
key. When called in list context this will return all values for the given key.
.IP "headers" 4
.IX Item "headers"
Returns an HTTP::Headers object containing the headers for the current
request.
.IP "param" 4
.IX Item "param"
When called with no arguments this will return a list of all parameter names.
When called in scalar context this will return the last value for the given
key. When called in list context this will return all values for the given key.
.IP "params" 4
.IX Item "params"
Returns a Hash::MultiValue hash reference containing the merged \s-1GET\s0 and \s-1POST\s0
parameters.
.IP "cookie" 4
.IX Item "cookie"
When called with no arguments this will return a list of all cookie names.
When called in scalar context this will return the last cookie for the given
key. When called in list context this will return all cookies for the given
key. A cookie should look like this:
.Sp
.Vb 4
\&    {
\&        \*(Aqname\*(Aq => \*(Aqfoo\*(Aq,
\&        \*(Aqvalue\*(Aq => \*(Aqbar\*(Aq,
\&    }
.Ve
.IP "cookies" 4
.IX Item "cookies"
Returns an Hash::MultiValue containing all cookies.
.IP "upload" 4
.IX Item "upload"
When called with no arguments this will return a list of all upload names.
When called in scalar context this will return the last
Prancer::Request::Upload object for the given key. When called in list
context this will return all Prancer::Request::Upload objects for the given
key.
.IP "uploads" 4
.IX Item "uploads"
Returns an Hash::MultiValue containing all uploads.
.IP "uri_for" 4
.IX Item "uri_for"
Generates a \s-1URL\s0 to a new location in an easy to use manner. For example:
.Sp
.Vb 1
\&    my $link = $request\->uri_for(\*(Aq/logout\*(Aq, [ signoff => 1 ]);
.Ve
